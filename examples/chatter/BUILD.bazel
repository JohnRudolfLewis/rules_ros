"""Implements an example to demonstrate:

- Defining ROS messages.
- Generating C++ and Python ROS message definitions.
- Defining C++ and Python ROS nodes.
- Defining a ROS deployment -- i.e. a ROS-launch Bazel target.
- Defining a Bazel target for running ROS-topic introspection functionality.
"""

load(
    "@rules_oci//oci:defs.bzl", 
    "oci_image", 
    "oci_load"
    )
load("@rules_pkg//pkg:pkg.bzl", "pkg_tar")
load("@rules_python//python:defs.bzl", "py_binary")
load("//ros:cc_defs.bzl", "cc_ros_binary")
load(
    "//ros:interfaces.bzl",
    "cc_ros_interface_library",
    "py_ros_interface_library",
    "ros_interface_library",
)
load("//ros:launch.bzl", "ros_launch")
load("//ros:test.bzl", "ros_test")
load("//ros:topic.bzl", "ros_topic")

# Handling of ROS messages & services resembles to some extent Bazel's rules for
# handling protobuf messages (e.g. proto_library and cc_proto_library).

# Defines a library of ROS messages. Can be used for services as well.
ros_interface_library(
    name = "example_msgs",
    srcs = ["Example.msg"],
    deps = ["@ros_std_msgs//:std_msgs"],
)

# Defines a C++ library made of auto-generated code from the given messages.
cc_ros_interface_library(
    name = "cc_example_msgs",
    visibility = ["//visibility:public"],
    deps = [":example_msgs"],
)

# Defines a Python library made of auto-generated code from the given messages.
py_ros_interface_library(
    name = "py_example_msgs",
    visibility = ["//visibility:public"],
    deps = [":example_msgs"],
)

# Defines a talker ROS node.
cc_ros_binary(
    name = "talker",
    srcs = [
        "talker.cc",
    ],
    deps = [
        ":cc_example_msgs",
        "@ros_comm//:roscpp_lib",
    ],
)

# Defines tests for the talker node.
ros_test(
    name = "talker_tests",
    launch_file = "talker_tests.launch",
    nodes = [
        ":talker",
        "//third_party/ros/rostest:advertisetest",
        "//third_party/ros/rostest:publishtest",
    ],
)

# Defines a C++ listener ROS node.
cc_ros_binary(
    name = "listener",
    srcs = [
        "listener.cc",
    ],
    deps = [
        ":cc_example_msgs",
        "@ros_comm//:roscpp_lib",
    ],
)

# Defines a Python listener ROS node.
py_binary(
    name = "py_listener",
    srcs = ["listener.py"],
    main = "listener.py",
    deps = [
        ":py_example_msgs",
        "@ros_comm//:rospy",
    ],
)

# Defines a launch target with talker and listener. Just run as
# `bazel run //examples/chatter:chatter`. This will build the two nodes,
# the deployment and start the launcher.
ros_launch(
    name = "chatter",
    launch_files = ["chatter.launch"],
    nodes = [
        ":talker",
        ":listener",
        ":py_listener",
    ],
)

# catkin workflow gives to rostopic app ability to handle all messages that
# live the devel/install workspace. With Bazel workflow we don't have that.
# Here, rostopic is deployment-specific.
# Example usage: `bazel run //examples/chatter:rostopic -- echo /chatter`
ros_topic(
    name = "rostopic",
    deps = [":chatter"],
)

# packages up the nodes, launch file, and all the other required runfiles.
# Note the symlink is required in order to place the files where ros_launch is
# expecting them to be.
pkg_tar(
    name = "chatter_tar",
    srcs = [
        ":chatter",
    ],
    include_runfiles = True,
    package_dir = "chatter",
    symlinks = {
        "/chatter/chatter.runfiles/_main/external": "/chatter/chatter.runfiles",
    }
)

# builds the oci image on top of the @base-image defined at the MODULE level. 
# Note that even though the version of python that the nodes run in is contained
# in the runfiles, a version of python is required at the system level in order
# to run the roslaunch command.
oci_image(
    name = "chatter_oci_image",
    base = "@base-image",
    tars = [":chatter_tar"],
    workdir = "/chatter/chatter.runfiles/_main",
    entrypoint = ["/chatter/chatter"],
)

# loads the oci image into the docker daemon.
# Example usage: `bazel run //examples/chatter:chatter_oci_load`
# Then to run the container: `docker run -it --rm chatter:latest`
oci_load(
    name = "chatter_oci_load",
    image = ":chatter_oci_image",
    repo_tags = ["chatter:latest"],
)
